[{"title":"基于SOOT框架的JAVA指针分析","date":"2019-07-19T02:05:49.000Z","path":"/CodeAnalyse/","text":"概述code研一在国科大暑假小学期，选修了北大熊英飞和张路老师的《程序分析》，上课期间，很多时候都是云里雾里。课程结束后，留有一个大作业「实现一个JAVA上的指针分析系统」。花了几天时间，终于将其搞定，于是决定当一个“事后诸葛亮”，整理下大作业实现的思路，简单系统的讲述下如何完成这个系统。 需求 利用开源框架，如SOOT程序分析框架，对JAVA程序进行指针分析。 输入： 1234567891011public static void main(String[] args) &#123;Benchmark.alloc(1); //标记分配点A a = new A();Benchmark.alloc(2);A b = new A();Benchmark.alloc(3);A c = new A();if (args.length&gt;1) a=b;Benchmark.test(1, a); //标记测试点编号和被测变量Benchmark.test(2, c);&#125; 输出： 121: 1 22: 3 上述需求是这样理解的，alloc(1)表示一开始new A()得到的地址标号为1，同理得到b、c的地址标号。最后输入测试变量，得到a可能在的地址标号。以a分析举例，一开始，A a = new A()，可以确定a变量对应有地址1，然后在if (args.length&gt;1) a=b;语句之后，a还可能有地址2，然后，合并分支，可以得到a可能在的地址为1和2。 分析刚开始接触到这个大作业，应该先根据理论知识，确定相应的几个核心问题，然后根据问题，我们逐步提出软件框架，最后设计出整个系统。首先，是核心问题的提出，我们需要思考的问题包括： 1 指针分析中，半格应该是什么？程序怎样来表示半格？2 JAVA程序中，存在哪几种操作，该操作会影响指针的指向？这些操作，对应的半格操作是什么？3 对于域敏感的指针分析，如何处理域敏感？假设存在类A，其表示为： 12345class A &#123; B f; &#125;class B &#123;&#125; 那么对于两个A变量a和b，赋值操作a=b，那么对于a.f以及b.f。它们是否是相同的。4 程序中，存在条件选择函数，按照程序分析的假设，要认为每条支路都当做一条支路，如何实现分支，半格在其中如何变化，最后如何实现合并？5 程序中，存在函数调用，也就是程序间程序分析，假设存在这样的调用： 1234567fun1 () &#123; int a, b; fun2(a, b);&#125;fun2 (int c, int d) &#123; d = c;&#125; 如何使得fun1中的a和b参数与fun2中的d和c对应起来。同时，每个函数域中存在很多的同名函数，则如何让他们不会相互影响？ 程序实现根据上述问题的分析，我们可以可以慢慢整理出一个框架，具体过程就不再赘叙，我就直接用我接触初步实现的代码框来说明。 Variable类Variable类用于表示半格变量，它需要实现下述功能： 对于程序中出现的每个变量，都应该有一个对应的Variable对象。 Variable中需要一个对象，用于存储半格变量，也就是地址标号。以及相应对地址标号的操作，如添加获取等。 在程序分析时，遇到分支，半格在不同分支会有不同的变化值，然后在分支汇合处进行合并操作。因此，需要为Variable类实现复制操作，在不同分支，都具备单独的半格变量。（因为如果只是=只是引用，并不是复制），注意Member变量的复制，浅复制只是引用！！ 由于我们需要进行域敏感分析，因此需要保存每个对象相应的成员函数。因此，在每个Variable中，还应该具备成员变量，成员变量中包含了成员对应的Variable对象。 在JAVA中与指针相关的操作，实际上就是赋值操作，我们需要模拟该操作。 因此，我们可以确定Variable类的简单框架： 12345678910class Variable &#123; Local local; //程序中对应的变量 Member member; Set&lt;Integer&gt; sourceId; Variable copy(boolean depp); // deep则对Member变量也进行复制，否则只是复制Member的引用 void assign(Variable var); void addId(int id); Set&lt;Integer&gt; getSourceId();&#125; Member类Member类主要用于表示成员变量，用于存储成员变量与Variable对象的映射关系。因此它需要实现下面功能： 具有一个映射表，能够根据成员变量描述，得到相应的Variable对象。 由于类包含有映射表，Variable需要实现复制，因此其也要实现复制操作。 添加映射关系等。 因此，我们可以确定Member类的简单框架。 12345678class Member &#123; Value value; Map&lt;SootFieldRef, Variable&gt; fieldMap; Member copy(); Variable getVariable(SootFieldRef sfr); void addField(SootFieldRef sfr, Variable var);&#125; Analyzer类Analyzer类主要实现指针分析的整体的半格操作。它需要实现下面功能： Analyzer系统中只能存在一个。 需要设置内存位置标号。 存在一个映射表，通过该表，我们可以找到所有变量对应的半格，也就是Variable对象，然后又因为存在不同分支，因此对于一些变量，其对应有多个半格。同时，需要对这个映射表进行简单的添、查操作。 需要记录查询的标号以及变量对应关系。 根据查询的标号以及变量对应关系，将对应变量的所有半格进行合并，得到最终结果。 因此，我们可以确定Analyzer类的基本框架。 123456789101112class Analyzer &#123; int allocId; Map&lt;Local, Set&lt;Variable&gt;&gt; localMap; Map&lt;Integer, Local&gt; queries; void setId(); int getId(); void addVar(Local local, Variable var); Set&lt;Variable&gt; getVars(Local local); void addQuery(int id, Local local); String run();&#125; Contex类在程序运行中，对于选择函数，则会产生分支，对于函数调用，则会进入一个新的运行区域，对于该区域，半格以及变量都会有所不同，因此，我们需要对该种行为进行一个抽象，因此我们抽象一个Contex对象，该对象模拟该种情况。因此该类需要实现下面功能： 对于每个函数体内，具有独立的变量映射表。 对于函数调用，需要将调用函数体内的变量与当前函数的参数进行联系。注意，函数调用后，只会影响对象的内部对象的指针指向！！ 对于程序中的分支（If等），其与主分支变量相同，但是需要复制一份，因为在不同分支中具备不同的半格变化表示。 需要判断是否进入递归函数或者分支循环。 注意点，创建分支区域与创建函数子区域是不同的。创建一个分支域!!!!需要复制半格，并且是deep复制，因为在分支内，对象及其内部成员都会受到影响。而创建函数子区域，则无需复制操作。在进行函数调用后，需要将参数与上层函数域内变量对应，简单的想，只要将上层对应变量的Variable与该层的Local对应就行了，这样在该域内，对该域的Local操作，然后相应进行半格操作。但是由于函数调用，不会改变对象本身的指针！！！！只能改变对象成员的指针，因此，我们此时与该域对应的参数的Local对应的应该是上层相应变量的Variable的浅复制，这样该域内可以改变对象的成员指针，但是不能改变对象本身指针，举例说明： 123456789101112131415161718192021222324252627282930class A &#123; B o; public A() &#123; o = new B(); &#125;&#125;class B &#123; public B() &#123; &#125;&#125;public class MyPointerAnalysis &#123; static void swap(A a, A b) &#123; a.o = b.o; &#125; public static void main(String[] args) &#123; A a = new A(); A b = new A(); System.out.println(&quot;a: &quot; + a.hashCode() + &quot; b: &quot; + b.hashCode()); System.out.println(&quot;a.o: &quot; + a.o.hashCode() + &quot; b.o: &quot; + b.o.hashCode()); swap(a, b); System.out.println(&quot;a: &quot; + a.hashCode() + &quot; b: &quot; + b.hashCode()); System.out.println(&quot;a.o: &quot; + a.o.hashCode() + &quot; b.o: &quot; + b.o.hashCode()); &#125;&#125; 上述程序的输出结果是： 1234a: 2018699554 b: 1311053135a.o: 118352462 b.o: 1550089733a: 2018699554 b: 1311053135a.o: 1550089733 b.o: 1550089733 由此可见！因此，我们可以确定Contex类的基本框架：： 1234567891011121314151617181920212223class Contex &#123; Analyzer analyzer; // 存在不同的半格分支，需要analyzer保存某个变量的所有半格 String methodSignature; // 所在的函数体 Contex invokeMethod; //保存该函数被调用所在的函数体的指正，从而能够将函数参数与上一个函数域对应 List&lt;Value&gt; args, Contex preBranch; // 用于保留分支前的支流指针，比如 存在分支 A-&gt; B, A -&gt; C，那么B,C对应的Contex保留的为A Map&lt;Local, Variable&gt; localMap; //在该域内，变量及其对饮的半格 //创建一个函数调用的新域， Contex createInvokeContex(String methodSignature, List&lt;Value&gt; args, Variable thisVar)； //创建一个分支域!!!!需要复制半格，并且是deep复制，因为在分支内，对象及其内部成员都会受到影响 Contex createBranchScope(String branchSignature)； // 将变量与半格对应 void bindLocalAndVariable(Local local, Variable var); // 简单来说就是将上层函数域中对应的变量的半格，浅复制一下，与当前域的local进行对应。 void bindArg(Local local, int paramIndex); // 对于函数域内，变量的声明对应的Local，建立Variable与其对应 void bindThis(Local local); // 判断是否递归 boolean isInRecursion(String invokeSignature); // 判断分支是否递归 boolean isInBranchChain(String branchSignature);&#125; MyTransformer类该类主要就是调用SOOT框架，SOOT框架将java文件以及class文件转化为相应的jimple文件，通过调用框架，针对各种情况进行分析，具体要看代码。因此可以得到该类的基本框架为： 1234567class MyTransformer extends SceneTransformer &#123; @Override protected void internalTransform(String arg0, Map&lt;String, String&gt; arg1); void solveMethod(SootMethod method, Contex contex); void solveBlock(Unit u, Contex contex, UnitGraph graph); void solveUnit(Unit u, Contex contex); 关于SOOT一些简单使用如何调用soot框架需要导入的包: 12import soot.PackManager;import soot.Transform; 启动使用soot进行程序分析 首先，你要创建一个继承SceneTransformer的类，并重写函数protected void internalTransform(String s, Map&lt;String, String&gt; map)来实现你自己在程序分析中的一些处理。 注册重写的Transformer类： 1PackManager.v().getPack(&quot;wjtp&quot;).add(new Transform(&quot;wjtp.myapp&quot;, new MyTransformer())); 在主函数中，启动soot函数： 12345678soot.Main.main(new String[]&#123; &quot;-w&quot;, &quot;-f&quot;, &quot;J&quot;, &quot;-p&quot;, &quot;cg.spark&quot;, &quot;enabled:true&quot;, &quot;-p&quot;, &quot;wjtp.myapp&quot;, &quot;enabled:true&quot;, &quot;-soot-class-path&quot;, &lt;包含运行时包含soot的jar包路径&gt;, &lt;分析的代码的入口类，比如 App.Main&gt; &#125;); ** 通过分析图函数，来逐步分析每个节点 导入包 1234import soot.*;import soot.jimple.*;import soot.toolkits.graph.BriefUnitGraph;import soot.toolkits.graph.UnitGraph; 开始依次执行 1234567891011// 获取main函数SootMethod mainMethod = Scene.v().getMainMethod();// 获取main函数的函数体Body body = mainMethod.getActiveBody();// 基于函数体，创建程序分析图UnitGraph graph = new BriefUnitGraph(body);// 获取其头节点Unit head = graph.getHeads().iterator().next();// 获取每个节点的后续节点List&lt;Unit&gt; succs = graph.getSuccsOf(head);List&lt;Unit&gt; succs = graph.getSuccsOf(u); 一些语句实体的类型及相关操作 12345678910111213141516IdentityStmt is //定义语句 exp: r0 := @this: test.FieldSensitivity// 获取语句的两侧操作数或定义字符Value lop = is.getLeftOp()Value rop = is.getRightOp()ParameterRef pr // 参数定义语句 如： benchmark.objects.Apr.getIndex() // 参数在函数调用中的位置ThisRef tr // this定义 如： @this: benchmark.objects.BAssignStmt as // 赋值语句，如： r4 = $r9AnyNewExpr ae // new 语句，如： new benchmark.objects.BNewArrayExpr // new 数组Local // 局部变量，比如： $r3 如果要对某个对象的内部值进行赋值或者操作，比如A.name = B.name，相关操作。 12345678// 首先获取FieldRefFieldRef fr// 该类型用于表示表达式是否是存在域内部操作的，如： r3.&lt;benchmark.objects.A: benchmark.objects.B f&gt;// 获取纯内部对象类型SootFieldRef sr = fr.getFieldRef() 如： &lt;benchmark.objects.A: benchmark.objects.B f&gt;// 获取实际操作的操作Local rbase = (Local) fr.getBase(); 如 r3InstanceFieldRef // 就是实例赋值 r3.&lt;benchmark.objects.A: benchmark.objects.B f&gt; 函数调用类的。 12345678InvokeStmt // 函数调用的表达式，如： specialinvoke $r9.&lt;benchmark.objects.B: void &lt;init&gt;()&gt;()InvokeExpr ie // 与上上式类似 如： specialinvoke $r9.&lt;benchmark.objects.B: void &lt;init&gt;()&gt;()SootMethod invokeMethod = ie.getMethod(); // 获取调用的函数String methodSignature = invokeMethod.getSignature(); //获取函数标签List&lt;Value&gt; invokeArgs = ie.getArgs(); //获取参数InstanceInvokeExpr // 实例初始化调用函数，如： specialinvoke r0.&lt;test.FieldSensitivity: void assign(benchmark.objects.A,benchmark.objects.A)&gt;(r2, r3)","comments":true,"tags":[{"name":"SOOT","slug":"SOOT","permalink":"http://victorjiangxin.github.io/tags/SOOT/"},{"name":"JAVA","slug":"JAVA","permalink":"http://victorjiangxin.github.io/tags/JAVA/"},{"name":"程序分析","slug":"程序分析","permalink":"http://victorjiangxin.github.io/tags/程序分析/"}]},{"title":"go语言学习","date":"2019-06-12T10:48:00.000Z","path":"/golang-note/","text":"Go语言优点 快速编译，高效执行，易于开发 对网络通信、并发和并行编程的极佳支持 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收 能够轻松对第三方包进行部署，并且支持调用C语言编写的库 P.S:GO语言的实时性不高！C语言的实时性高 看懂GO代码-简单知识点函数启动点一般会先执行main.mian()也就是main包中的main函数，如果文件中有init()函数，则会先执行init()函数。 变量声明:var name type GO可以自动推导类型: var a = false 局部变量： a := 1 函数形式1234func functionName(parameter_list) (return_value_list)&#123; &#125;parameter_list: (param1 type1, param2 type2, ...)return_value_list: (ret1 type1, ret2 type2) 类型 基本类型：int、float、bool、string 结构化类型：struct、array、slice、map、channel 只描述类型行为：interface 自定义类型: 12type IZ intvar a IZ = 5 这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。 类型转换Go不支持隐式转换，只支持显式转换！ 简单示例1234567891011121314151617181920212223242526272829package mainimport ( \"fmt\")const c = \"C\"var v int = 5type T struct&#123;&#125;func init() &#123; // initialization of package&#125;func main() &#123; var a int Func1() // ... fmt.Println(a)&#125;func (t T) Method1() &#123; //...&#125;func Func1() &#123; // exported function Func1 //...&#125; Reference https://github.com/yangwenmai/learning-golang","comments":true,"tags":[{"name":"go","slug":"go","permalink":"http://victorjiangxin.github.io/tags/go/"}]},{"title":"基于Linear-CRF(线性条件随机场)的中文分词","date":"2019-05-25T06:00:55.000Z","path":"/Chinese-Word-Segmentation/","text":"代码https://github.com/VictorJiangXin/Linear-CRF/ Motivation研一下选修了宗成庆老师的「自然语言处理」，课程要求完成一系列的大作业，然而已是拖延症晚期的我，一直将其晾在一边，直到今天，才真正开始启动项目。由于实验室资源匮乏，没有GPU，因此只能选择使用传统方法能够完成的大作业，最终确定中文分词实验。 话不多说，先看前沿论文，看看当前中文分词的baseline。 Bidirectional LSTM-CRF Models for Sequence Tagging, Kai Yu, 2015 由上图可知，2015年前，使用BI-LSTM+CRF模型，中文分词的效果最好，其相对准确度最高。但将其与传统的CRF方法比较，竟然只是个位数的提升！！！而且还要耗费巨大的计算量，使用GPU进行训练，这实在不是个划算的生意！总体而言，深度学习在自然语言处理方向的应用，对于机器翻译的提升最大，而其他比较传统的NLP任务，比如句法分析，实体标注等，使用传统的方法已经能够有非常好的效果了。因此，果断选择使用CRF(条件随机场)，来完成中文分词任务。 目前，已经有非常多的开源CRF包了，而且也非常好用，直接用这些包完成中文分词任务将会十分简单。但是，直接使用CRF包，就太没挑战性了，也不能够促进对知识点的理解，重点是——没有情怀！搞科研，最重要的是情怀，^_^，要有将知识转为实践的能力。因此，本次决定用Python实现一个简单的Linear-CRF模型（线性链条件随机场），用于完成中文分词任务，Let’s Go! CRF 条件随机场要了解CRF，最好先了解下隐马尔科夫模型，可以先看看隐马尔科夫模型在分词上的应用 ，先对HMM有个简答的了解，然后再理解CRF可以更容易些。 首先，什么是CRF(条件随机场)？如下图所示，白色的点表示为$Y$，黑色的点表示为$X$，设$X$与$Y$是随机变量，$P(Y|X)$是在给定$X$的条件下$Y$的条件概率分布，若随机变量$Y$构成了一个由无向图$G=(V,E)$表示的马尔可夫随机场，即： $$P(Y_v|X, Y_w, w\\ne v)=P(Y_v|X,Y_w,w\\sim v)$$ 则称$P(Y|X)$为条件随机场。简而言之，就是随机变量$Y$所在的节点的随机变量，概率分布只与与其连接的节点有关。 CRF结构图 Linear CRF(线性链条件随机场)线性条件随机场是条件随机场的一种，其结构如上图的中间所示，随机变量$Y_t$的分布，除了给定的随机变量$X$外，只与其前后的随机变量$Y_{t-1}$以及$Y_{t+1}$有关。本次分词任务所用的即为线性条件随机场，后文所介绍皆以线性条件随机场为主，所称CRF也都指线性条件随机场，后文将不再赘述。 线性链条件随机场的参数化形式设$P(Y|X)$为线性链条件随机场，则在随机变量$X$取值为$x$的条件下，随机变量$Y$取值为$y$的条件概率具有以下形式(上面所说的$x$，$y$均表示一个序列)：$$P(y|x)=\\frac{1}{Z(x)} exp\\left( \\sum_{i,k}{\\lambda_k t_k (y_{i-1}, y_i, x, i) + \\sum_{i,l}{\\mu_i s_l(y_i, x, i)}}\\right)$$ 其中，$$Z(x) = \\sum_{y}{exp\\left(\\sum_{i,k}{\\lambda_k t_k (y_{i-1}, y_i, x, i) + \\sum_{i,l}{\\mu_i s_l(y_i, x, i)}} \\right)}$$ 上式中，$t_k$和$s_l$为特征函数，$\\lambda_k$和$s_l$代表的是对应的权值，$Z(x)$对应的是规范化因子。其中，特征函数一般随任务自由设定，其值一般为0或者1，而条件随机场需要训练的就是相关的权重值，比如$\\lambda_k$与$s_l$。 简单点，表达的方式简单点由于条件随机场在同一特征的各个位置中都有定义，可以对同一个特征在各个位置进行求和，将局部特征函数转化为一个全局特征函数，这样可以将条件随机场写成权值向量和特征向量的內积形式，即其简化表示，首先将转移特征与状态特征用统一的符号进行表示，设有$K_1$个转移特征，$K_2$个状态特征，$K=K_1+K_2$，记： 同理，用$w_k$表示特征$f_k(y,x)$的权值，即： 因此，条件随机场可表示为：$$P(y|x)=\\frac{1}{Z(x)} exp \\sum_{i=1}^n{\\sum_{k=1}^K{w_kf_k(y_{i-1}, y_i, x, i)}}$$ $$Z(x)=\\sum_{y}exp \\sum_{i=1}^n{\\sum_{k=1}^K{w_kf_k(y_{i-1}, y_i, x, i)}}$$我们常用矩阵去进行表示并进行相关计算，以$w$表示权重向量，即：$$W=(w_1,w_2,…,w_K)^T$$而求得位置$i$对应的所有的特征表示为：$$F_i(x,y)=[f_1(i,x,y_i,y_{i-1}),f_2(i,x,y_i,y_{i-1}),…,f_K(i,x,y_i,y_{i-1})]^T\\$$该等式表示的是位置$i$对应的相关特征，比如$F_1(x,y)=[1,0,0,0,1,0,0]$表示对于给定的$x$，$y$序列在序列的第一个位置，其具有相应的$f_1$特征，$f_5$特征。因此，此时条件随机场的计算可以表示为：$$P(y|x)=\\frac{1}{Z(x)} exp(W^T.\\sum_{i=1}^{n}{F_i(x,y)})$$比如： $$X=(x_1,x_2)$$ $$X=(x_1,x_2)$$ $$Y=(Y_1,Y_2)$$ $$W=(w_1,w_2,w_3,w_4)$$ 为了计算$P(y|x)$，先计算各个位置对应的特征值，为: $$F_1=[1,0,0,1]$$ $$F_2=[0,1,0,1]$$$$F=F_1+F_2=[1,1,0,2]$$ $$P(y|x)=\\frac{1}{Z(x)}exp((w_1,w_2,w_3,w_4).(1，1，0，2)^T)=\\frac{1}{Z(x)}exp(w_1+w_2+2w_4)$$ 同理，再去求$Z(x)$可以得到相关值，但$Z(x)$有其他计算方法，后面会再介绍。 只用公式太枯燥了，让我们举个栗子吧！以分词任务为例，$x$表示语句”今晚/月色/真/美”，而$y$采用常用的分词标注次，即为$y={B,E,I,S}$，其中$B$表示词语的开头，$E$表示词语的结尾，$I$表示词语的中间词，$S$表示单个词，则栗子中$y$对应的序列应该为$BEBESS$。而特征只举简单的栗子，只对单个词取特征，因此我们的特征对应为： $$s_1=s_1(y_i=B,x[i]=’今’)\\ \\lambda_1=1$$$$s_2=s_2(y_i=E,x[i]=’今’)\\ \\lambda_2=0.5$$$$s_3=s_3(y_i=S,x[i]=’今’)\\ \\lambda_3=0.2$$$$s_4=s_4(y_i=I,x[i]=’今’)\\ \\lambda_4=0.3$$$$s_5=s_5(y_i=B,x[i]=’晚’)\\ \\lambda_5=0.5$$$$s_6=s_6(y_i=E,x[i]=’晚’)\\ \\lambda_6=0.5$$$$s_7=s_7(y_i=S,x[i]=’晚’)\\ \\lambda_7=0.5$$$$s_8=s_8(y_i=I,x[i]=’晚’)\\ \\lambda_8=0.5$$$$…$$$$t_1=t_1(y_{i-1}=E,y_i=E)\\ \\mu_1=0.5$$$$t_2=t_2(y_{i-1}=B,y_i=E)\\ \\mu_2=0.5$$$$…$$ 这些特征只有在满足条件时为1，否则为0。而右边的$\\lambda$以及$\\mu$是模型的参数，则对于此时，$P(y|x)$可表示为：$$P(y|x)=\\frac{1}{Z(x)} exp(\\lambda_1+\\lambda_6+…)$$上式值写了部分，其含义是，在第一个位置’今’，上面所列举的特征只有$f_1(y_1=B,x[1]=’今’)=1$，其余的特征对应为0，而第二个位置’晚’,上面所列举的特征只有$f_6(y_2=E,x[2]=’晚’)=1$。同理，可推导其他位置对应的特征，从而得到当前CRF模型下，对于给定$x$以及$y$对应的概率值。而$Z(x)$的要针对所有的$y$的可能进行累加，也就是类似语句”今晚/月色/真/美”对应的标记为$EEBESS$，$EEEESS$等等，所有的可能性，在当前CRF模型(给定特征权重参数情况下)，计算得到的概率的和。 条件随机场的矩阵形式条件随机场可以由矩阵表示，假设$P_w(y|x)$是线性链条件随机场，表示给定观测序列$x$，相应的标记序列$y$的条件概率，引进特殊的起点和终点状态标记$y_0=start$，$y_{n+1}=end$，$y$可表示为$m$中形式即$y$的表示形式可以为$Y=(Y_1,Y_2,…,Y_m)$，则此时的$P_w(y|x)$可以通过矩阵形式表示。 对观测序列$x$的每一个位置$i=1,2,…,n+1$，定义一个$m$阶矩阵： 因此，此时的条件概率$P(y|x)$可以表示为：$$P_w(y|x)=\\frac{1}{Z(x)}\\prod_{i=1}^{n+1}{M_i(y_{i-1},y_i,x)}$$ $Z(x)$规范化因子，则可表示为$(n+1)$个矩阵乘积中的元素：$$Z_w(x)=(M_1(x),M_2(x),…,(M_{n+1}(x)))_{[start][end]}$$ 为什么 $x$ 序列只有 $n$ 个元素，但是这里M矩阵有$n+1$个呢？因为，我们人为的添加了start与end。此时要注意，由于每个序列的start是确定的，因此，对于$M_1(x)$，只有$M_1(y_{0}=start, y_1)$ 不为零，其他的都为0。对于$M_{n+1}$只有$M_{n+1}(y_n, y_{n+1}=end)$ 为1， 其他都为0。 注意！！$M_i(x)$与$M_i(y_{i-1},y_i,x)$的区别，$M_i(x)$表示的是$m \\times m$的矩阵，而$M_i(y_{i-1},y_i,x)$只是该矩阵中，$y_{i-1},y_i$为确定表示的一个元素。 举个栗子，给定一个线性链条件随机场，观测序列$x$，状态序列$y$，$i=1,2,3$，$ n=3$，标记$y_i={1,2}$ 假设$y_0=start=1$，$y_4=stop=1$，各个位置的随机矩阵分别为： 从start到end对应的各个路径的非规范化概率分别是： 而计算矩阵$M_1(x)M_2(x)M_3(x)M_4(x)$，其第一行第一列对应的元素为： 条件随机场的概率计算问题前向向量 对于每个位置$i=0,1,..,n+1$，定义前向向量$\\alpha_i(x)_{m\\times 1}$，其表示给定序列$x$，前$(i-1)$个位置的标签可以为任意的，但第 $i$ 个标签为 $y_i$ 的概率： $$\\alpha_i^T(y_i| x)=\\sum_y{\\alpha_{i-1}^T(y|x)M_i(y, y_i| x)}$$ 也可表示成 因此，$\\alpha_0(x)$只有在start对应的标志处为1，其余为0。$\\alpha_{n+1}(x)$ 只有在end对应的标志处存在值，其值为$z(x)$。 后向向量 对于每个位置$i=0,1,..,n+1$，定义前向向量$\\beta_i(x)_{m\\times 1}$，其表示给定序列$x$，第$i$个元素为$y_i$，从第$i$到$n$为任意的标签的概率： $$\\beta_i(y_i| x)=\\sum_y{M_{i+1}(y_i, y| x)\\beta_{i+1}(y|x)}$$ 也可表示为： 由前向向量以及后向向量可以得到：$$Z(x)=\\alpha_{n+1}^T(x).\\bf1_{m\\times 1}=\\bf1_{m\\times 1}^T.\\beta_0(x)$$ 因此，$\\beta_{n+1}(x)$ 只有在end标志处为1，其余为0。$\\beta_0(x)$ 只有在start标志处为$z(x)$，其余为0。 概率计算 与HMM模型一样，已知前向-后向向量的定义，很容易计算标记序列在位置$i$是标记$y_i$的条件概率，以及在位置$i-1$与$i$是标记$y_{i-1}$和$y_i$的条件概率：$$P(y_i=Y_i|x)=\\frac{\\alpha_i^T(y_i=Y_i|x)\\beta_i(y_i=Y_i|x)}{Z(x)}$$，$$P(y_i=Y_i,y_{i-1}=Y_{i-1}|x)=\\frac{\\alpha_{i-1}^T(y_{i-1}=Y_{i-1}|x)M_i(y_{I-1}=Y_{i-1},y_i=Y_i|x)\\beta_i(y_i=Y_i|x)}{Z(x)}$$ 条件随机场的预测问题与HMM的预测问题一样，条件随机场的预测问题也用Viterbi(维特比)算法，进行推测，其原理如下图所示。每次一次都更新每一位置对应的所有可能显示结果对应的可能性，然后选取最大的一个最为当前位置的路径。 https://www.cnblogs.com/tornadomeet/archive/2012/03/24/2415889.html 因此相关算法可以描述为： 输入：模型特征向量$F(x,y)$和权值向量$W$，观测序列$x=(x_1,x_2,…,x_n)$。 输出：最优路径$y^*=(y_1^*,y_2^*,…,y_n^*)$ 初始化 $$\\sigma_1(j)=W.F_1(y_0=start,y_1=j|x), j=1,2,..,m$$ 递推，对$i=1,2,3…,n$ $$\\sigma_i(l)=\\max_{1\\leq j\\leq m}{\\sigma_{i-1}(j)+W.F_i(y_{i-1}=j,y_i=l,x)},l=1,2,…,m$$ $$\\psi_i(l)=\\arg \\max_{1\\leq j\\leq m}{\\sigma_{i-1}(j)+W.F_i(y_{i-1}=j,y_i=l,x)},l=1,2,…,m$$ 终止 $$\\max_y(W.F(y,x))=\\max_{1\\leq j\\leq m}\\sigma_n(j)$$ $$y_n^*=\\arg \\max_{1\\leq j\\leq m}\\sigma_n(j)$$ 返回路径 $$y_i^*=\\psi_{i+1}(y_{i+1}^*)，i=n-1,n-2,…,1$$ 训练CRF训练是最重要的一点，主要用于训练得到CRF的权重矩阵，看了很多博客和李航的《统计学习方法》都写的很复杂，看完也不知道如何进行训练，最后还是在CRF的WIKI上，找到相关开源CRF的指导手册(万能的维基百科！)，终于找到了一种实用的用于训练的算法。它采用L-BFGS优化算法进行优化，在给定训练集$D=(X,Y)$的情况下，其对数似然为： 对应于之前的公式，其实左边等式的和就是$\\log P_w(y|x)$，具体看条件随机场的矩阵部分。 其相应的对数形式下，损失函数的梯度表示为： 第一项就是预料中，对于该语料，每一特征出现的次数。第二项则是，对于某一个给定的$x$，先求出所有的$p(i, y_{i-1}, y_i)$，这个可以通过前向概率，后向概率计算得到，具体看前文。然后求出对应的$f_k(y_{i-1}, y_i)$，最后得到相应的值。相关伪代码如下： 1234567891011121314def feature_at(x, y_pre, y_now, k): \"\"\" k is index of feature \"\"\" if xx: return True return Falsedef gradient(x): gradient_item2 = np.zeros(weights.shape[0]) for i in range(len(x)): for y_pre in range(ntags): for y_now in range(ntags): for k in range(weights.shape[0]): gradient_item2[k] += feature_at(x, y_pre, y_now, k) * P(i, y_pre, y_now) 但是，在实际代码中，每次遍历一次特征是非常慢的，由于给定一个序列 $x$ ，其具有的特征是确定的，因此，可以直接找到对应的 $k$ 进行运算，具体看代码。 P.S CRF的训练，要求使得对数似然函数最大化！！！不是最小化，如果使用最小化策略去优化，一定要对他们取负。 基于线性链条件随机场的中文分词在理解完成上述CRF各个公式的含义及概念后，则问题就变得简单了，就是按照上述提供的公式，将其计算出来。 中文分词特征是什么？条件随机场中特征一般分为两种，一种是U特征，也就是状态特征；另一种是B特征，也就是转移特征。U特征常常表示为(U, pos_shif, y,x,index, word)，其一般为： 12345678(U, -1, y, x, index, word, tag): if (x[index+-1] == word &amp;&amp; y[index] == tag): return 1; else return 0;(U, 0, y, x, index, word, tag): if (x[index+0] == word &amp;&amp; y[index] == tag): return 1; else return 0; 即该特征对应的是文字本身的前后文信息。 B特征常常表示为(B,tag_pre, tag_now)，其一般为： 1234(B, tag_pre, tag_now) if(y[index] == tag_now &amp;&amp; y[index-1] == tag_pre): return 1 else return 0; 也就是说B特征表示的是变量y包含的状态转移信息。 而特征的数量为（$U_{count}\\times V_{word}\\times m+ m \\times m$）。其中$U_{count}$表示U特征提取的位置数目，比如只提取文字前1个，当前文字，文字后一个，则此时$U_{count}=3$，$V_{word}$为语料库中文字数量，$m$表示$y$的标签数，即$y$的表现形式，对于每个文字，都有存在你一种表现形式的可能，因此要乘以m。B特征代表前一个标签到当前标签的转移概率。 推测分词结果在训练好模型后，按照Viterbi算法，推到出最可能的y序列，则得到相应的分词结果。 训练虽然我们已经知道了最大似然函数的表示以及梯度的计算公式，但是实际上，并不需要我们自己去写相关的优化器，直接使用传统的机器学习框架提供的minimize工具就行了，比如scipy.optimize.minimize。将相关的约束函数及对应导数作为参数输入，既可以得到相应的结果。 Corpus(语料库)北京大学语料库:https://pan.baidu.com/s/1gd6mslt GitHub作者liwenzhu，于14年发布于GitHub，总词汇量在7400W+，可以用于训练。https://github.com/liwenzhu/corpusZh 参考文献 http://flexcrfs.sourceforge.net/flexcrfs.pdf (flexcrfs是Python版本的开源包，该文档是其使用手册，本文引用了手册中的Train部分，即损失函数以及梯度计算。 L-BFGS优化方法介绍 https://people.cs.umass.edu/~mccallum/papers/crf-tutorial.pdf 宗成庆-《自然语言处理》课件-2019年春-计算所 胡玥-《自然语言处理》课件-2018年秋-信工所","comments":true,"tags":[{"name":"NLP","slug":"NLP","permalink":"http://victorjiangxin.github.io/tags/NLP/"},{"name":"中文分词","slug":"中文分词","permalink":"http://victorjiangxin.github.io/tags/中文分词/"},{"name":"Linear CRF","slug":"Linear-CRF","permalink":"http://victorjiangxin.github.io/tags/Linear-CRF/"}]},{"title":"Python_note","date":"2019-03-27T08:57:52.000Z","path":"/Python-note/","text":"参数在运行程序中，经常需要输入一系列的参数，用于指定文件夹之类的信息。常用的相关包有import argparse。下面是常用的用法 123parser = argparse.ArgumentParser(description=&apos;&apos;)parser.add_argument(&apos;--outf&apos;, default=&apos;./data/&apos;, help=&apos;folder to output images and model checkPoint&apos;)args = parser.parse_args()","comments":true,"tags":[{"name":"Python","slug":"Python","permalink":"http://victorjiangxin.github.io/tags/Python/"}]},{"title":"python3安装pymssql","date":"2018-07-22T10:57:46.000Z","path":"/python3-install-pymssql/","text":"提要由于在做项目中，需要通过python操作SQL Server数据库，在查看相关资料后，发现可以使用pymssql包，对数据库进行操作。本人使用的Python版本为3.5，查阅多种资料，都是推荐使用 pip install pymssql 但是，每次安装的时候，都出现错误，后来又尝试直接从pypi.org网站下载pymssql的包进行安装，进入相关包的路径后，输入python setup.py install但是仍旧是一堆错误。 解决在查看各种博客后，最终找到了解决方法。在微软的帖子里 微软的SQL帮助核心原因是，pip安装的程序需要再专门的网站里下载，即要下载对应版本的数据。下载地址 我是python3.5,64位，因此下载了 pymssql‑2.1.4.dev5‑cp35‑cp35m‑win_amd64.whl 然后进入下载的文件夹，运行指令 pip install pymssql‑2.1.4.dev5‑cp35‑cp35m‑win_amd64.whl从而成功安装。问题顺利解决","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://victorjiangxin.github.io/tags/python/"},{"name":"pymssql","slug":"pymssql","permalink":"http://victorjiangxin.github.io/tags/pymssql/"}]},{"title":"通过geth Json-Rpc接口遇到的坑","date":"2018-07-19T08:18:48.000Z","path":"/etheStudy/","text":"使用Python访问Geth遇到的问题在使用python对Geth提供的Json-RPC服务器进行访问时，一直返回由于目标计算机积极拒接、无法连接的错误，因此作出以下尝试： 使用python访问百度等官方网站，经测试，可以访问，说明当前配置无问题，问题出现在服务器端。 进入服务器，用netstat | grep 8545查看相关端口状态，发现端口一直处于Stopped状态。geth无法正常运行。经检测是磁盘空间不足，Geth数据无法同步，导致Geth运行失败，停止尝试。将.ethereum文件夹全部删除，重新运行geth –rpc，发现8545端口正常运行。 geth虽然端口正常运行，但是python仍旧无法去访问JsonRPC服务器。于是运行另一种geth命令。 geth –rpc –rpcaddr 10.21.41.1 –rpcport 8545。运行后，python能够从geth客户端获取信息问题解决。 问题原因，一开始访问 (ethereum JSONRPC的WIKI)[https://github.com/ethereum/wiki/wiki/JSON-RPC]里面提供了两种运行命令：geth --rpc该种默认rpcaddr是localhost.rpcport是8545。geth --rpc --rpcaddr &lt;xx&gt; --rpcport &lt;port&gt;该种情况是定义了IP和端口号，我以为localhost应该就是服务器的内网IP即 10.21.41.1但是，实际python访问是不行的，必须定义好rpcaddr，定义它为geth所在服务器的IP地址，从而才可以访问。","comments":true,"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://victorjiangxin.github.io/tags/以太坊/"},{"name":"Geth","slug":"Geth","permalink":"http://victorjiangxin.github.io/tags/Geth/"},{"name":"Json-RPC","slug":"Json-RPC","permalink":"http://victorjiangxin.github.io/tags/Json-RPC/"}]},{"title":"HunterCatchRabbits","date":"2018-07-18T02:00:22.000Z","path":"/HunterCatchRabbits/","text":"题目描述：假设卧底和特工有n个接头地点，编号为0和n-1。卧底每天晚上仅能换到相邻的接头地点，而特工每天白天在一个接头地点检查。 特工告诉你每天检查的接头地点的编号，希望你分析一下是否一定能与卧底碰头。输入描述：首先输入n和k（n&lt;100,k&lt;1000），分别表示接头地点的个数和特工检查的天数；接下来输入k个整数，表示特工每天检查的接头地点的编号。输出描述：如果一定能与卧底碰头，输出Yes，否则输出No。测试用例：1235 61 2 3 3 2 1Yes 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std; bool canCatchRibbit(vector&lt;int&gt; holeNums, vector&lt;int&gt; checked)&#123; int k = holeNums.size(); int n = checked.size(); bool flag = true; int cnt = n; // cnt为兔子能待的洞的个数，初试化为所有洞的个数 for (int i = 0; i &lt; k; i++) &#123; int holeNum = holeNums[i] - 1; // holeNum为洞的编号在vector中的序号， // 如：编号为1的洞在vector里面存的是0 if (checked[holeNum] == 1) &#123; checked[holeNum] = 0; cnt--; &#125; if (cnt == 0) // 如果兔子能待的洞的个数为0，则兔子肯定会被逮住 &#123; flag = false; break; &#125; for (int j = 0; j &lt; n; j++) &#123; if (checked[j] == 1) &#123; checked[j] = 0; cnt--; if (j&gt;0 &amp;&amp; checked[j - 1] == 0) &#123; checked[j - 1] = 1; cnt++; &#125; if (j &lt; n - 1 &amp;&amp; checked[j + 1] == 0) &#123; checked[j + 1] = 1; cnt++; j++; //原来值为0的洞现在为1后是不能往相邻的洞跳，故继续检查下一个洞 &#125; &#125; &#125; &#125; return flag;&#125; int main()&#123; int n, k; // n为洞的个数，k为检查的天数 cin &gt;&gt; n &gt;&gt; k; vector &lt;int&gt; holeNums(k, 0); // holeNums为每天检查的洞的编号 for (auto &amp;m : holeNums) cin &gt;&gt; m; vector&lt;int&gt; checked(n, 1); // checked为每天检查的洞中是否有兔子,可能有兔子则值为1， // 一定没兔子则值为0，全部初始化为1； bool flag = canCatchRibbit(holeNums, checked); if (!flag) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; return 0;&#125;","comments":true,"tags":[{"name":"算法","slug":"算法","permalink":"http://victorjiangxin.github.io/tags/算法/"}]},{"title":"linux文件编程","date":"2018-04-25T16:00:00.000Z","path":"/linux文件编程/","text":"概述Linux系统讲所有设备都当作文件来处理，因此Linux文件编程极其重要！linux文件编程设计到文件的读、写定位等各种操作。其中对文件的操作都只能由内核态完成，用户态想要访问文件只能通过系统调用。Linux文件编程中，最重要的一个概念便是文件描述符fd，所有文件的操作都通过文件描述符进行，每个文件对应一个文件描述符。打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符。 需要添加的函数库123#include &lt;fcntl.h&gt; //文件控制选项头文件#include &lt;unistd.h&gt; //针对系统调用封装#include &lt;sys/type.h&gt; 文件操作open 打开文件函数原型： int open(char *name, int how)功能： 打开一个文件 name: 文件名 how: 文件操作限制 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 读写 return -1: 打开失败 非零: 对应的文件描述符 create 创建文件函数原型： int fd = create(char *filename, mode_t mode)功能： 创建一个文件，如果源文件存在，则讲该文件清空 filename： 文件名 mode: 访问模式 COPYMODE return -1: 打开失败 非零: 成功创建 read 读数据函数原型: ssize_t read(int fd, void *buf, size_t qty)功能： 读取qty长度的数据到缓存buf中 fd: 所读文件的文件描述符 buf: 缓存 qty: 读取文件的长度 return: -1: 读取错误 非零: 读取的长度 write 写数据函数原型： ssize_t write(int fd, void *buf, size_t amt)功能： 将buf中数据写入文件中 fd: 所写文件的文件描述符 buf: 缓存 amt: 写进文件的长度 return: -1: 读取错误 非零: 写入的长度 lseek 定位文件指针函数原型： off_t lseek(int fd, off_t dist, int base)功能： 将文件指针定位到制定位置 fd: 操作的文件描述符 dist: 相对基位置的偏移量 base: 基位置 SEEK_SET 文件的开始 SEEK_CUR 当前位置 SEEK_END 文件结尾 return -1: 错误 其他： 指针变化前的位置 close 关闭文件函数原型： int close(int fd)功能： 关闭文件 fd: 需要关闭的文件 return -1: 错误 0: 关闭正确 处理系统调用中的错误errno内核通过全局变量来指定系统调用的类型，每个程序可以访问到该变量。一般不用它判断系统调用错误。 perror使用 perror(string)系统会自己查找调用错误的类型，并且将错误信息打印。","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://victorjiangxin.github.io/tags/linux/"},{"name":"文件操作","slug":"文件操作","permalink":"http://victorjiangxin.github.io/tags/文件操作/"}]},{"title":"linux获取时间及Socket编程","date":"2018-04-21T16:00:00.000Z","path":"/linux获取时间及Socket编程/","text":"如何获取时间UNIX时间戳：从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。UTC时间：世界协调时。以地球自转为基础的时间标准。 UTC表示方式为 年月日时分秒。 获取UNIX时间戳C运行库：#include &lt;sys/time.h&gt;运行环境： C语言运行环境函数： gettimeofday(struct timeval* tv, struct timezone* tz)功能： 获取当前UNIX时间戳相关结构体： 123456789struct timeval&#123; long tv_sec; //seconds long tv_usec; //microSeconds&#125;struct timezone&#123; int tz_minuteswest; //diff of greenwich int tz_dsttime; //type of DST correction&#125; 获取UTC时间C运行库：#include &lt;time.h&gt;运行环境： C语言运行环境函数1： char *ctime(const time_t *timer)功能1： 将UNIX时间戳转化成 Www Mmm dd hh:mm:ss yyyy (Mon Aug 13 08:23:14 2012)形式函数2： struct tm *gmtime(time_t *timer)功能2： 将UNIX时间转化成struct tm结构。相关结构体： 1234567891011struct tm&#123; int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;&#125; 注意： UTC时间年是以1900为参考点，记时间时需要year+1900， 时区是0时区，如果按照北京时间（东8区）需要tm_hour+8 测试代码： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;struct tm *GetBeijingTime();int main()&#123; struct tm *beijingTime; beijingTime = GetBeijingTime(); printf(&quot;%d/%d/%d %2.2d:%2.2d:%2.2d\\n&quot;, beijingTime-&gt;tm_year, beijingTime-&gt;tm_mon, beijingTime-&gt;tm_mday, beijingTime-&gt;tm_hour, beijingTime-&gt;tm_min, beijingTime-&gt;tm_sec);&#125;struct tm *GetBeijingTime()&#123; struct timeval tv; struct tm *BeijingTime; gettimeofday(&amp;tv, NULL); BeijingTime = gmtime((time_t*)&amp;(tv.tv_sec)); BeijingTime-&gt;tm_year += 1900; BeijingTime-&gt;tm_hour += 8; BeijingTime-&gt;tm_mon += 1; return BeijingTime;&#125; Socket编程包含的库： 12#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt; 服务器端 创建socket int socket(int domain, int type, int protocol) domain: 协议域，决定了socket的地址类型。 AF_INET: 用于IPV4网络通信 AF_UNIX: 单一Unix系统中进程间通信 AF_INET6: 用于IPV6网络通信 type: 制定socket类型。 SOCK_STREAM: 流式，一般用于TCP通信 SOCK_DGRAM: 数据包式，一般用于UDP通信 protocaol: 制定协议。 IPPROTO_TCP表示TCP协议，IPPROTO_UDP表示UDP协议，为0时自动选择type默认协议 return: -1 错误； 非负值 成功 绑定socket和端口号 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) sockfd: socket返回的套间字描述符，类似于文件描述符。 addr: 有个sockaddr类型数据的指针，指向的时被绑定结构变量 12345678910111213141516171819202122//IPV4的sockaddr地址结构struct sockaddr_in&#123; sa_family sin_family; //协议类型，AF_INET in_port_t sin_port; //端口号 struct in_addr sin_addr; //ip地址&#125;;struct in_addr&#123; uint32_t s_addr;&#125;//有关于sockaddr的相关函数htons() 将整形类型转换成网络字节序 比如 htons(INADDR_ANY),让系统自动获取本地IP地址htonl() 将长整形转换为网络字节序inet_pton(int af, char *str, pvoid addrbuf) 将点分十进制IP地址转换成网络字节 af: 协议域，与socket的domain一致 str: 要转换的地址 127.0.0.1 addrbuf: sinaddr的指针inet_ntop(int af, pvoid addrbuf, char *str, size_t len) 将网络字节序转换成分十进制IO地址 af: 协议域，与socket的domain一致 addrbuf: sinaddr的指针 str: 转换成的地址 len: 字节单位长度 addrlen: 地址长度 监听端口号 int listen(int sockfd, int backlog) sockfd: 要监听的sock描述字 backlog: socket可以排队的最大连接数 接收用户请求 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) sockfd: 服务器socket描述字 addr: 地址指针，保存用户对应的地址 addrlen： 地址长度。保存用户地址的长度 return: 一旦accept某个客户机请求成功，返回一个新的描述符，用于标识具体客户的TCP连接。 从socket中读取字符 ssize_t read(int fd, void *buf, size_t count) fd: 读取的用户对应的套间字描述字 buf: 保存接收信息的缓冲区 count: 读取的长度 return: 如果大于零表示读取的长度，返回0表示文件读取结束，小于0表示发生错误 向socket发送信息 ssize_t write(int fd, const void *buf, size_t count) fd: 发送的用户对应的套间字 buf: 缓冲区 count: 发送的信息长度 return: 如果大于零表示发送的长度，小于0表示发生错误 关闭socket int close(int fd) fd: accept返回的连接描述字，每个连接有一个，生命周期为连接周期。 ps: sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。客户端 创建socket int socket(int domain, int type, int protocol) domain: 协议域，决定了socket的地址类型。 AF_INET: 用于IPV4网络通信 AF_UNIX: 单一Unix系统中进程间通信 AF_INET6: 用于IPV6网络通信 type: 制定socket类型。 SOCK_STREAM: 流式，一般用于TCP通信 SOCK_DGRAM: 数据包式，一般用于UDP通信 protocaol: 制定协议。 IPPROTO_TCP表示TCP协议，IPPROTO_UDP表示UDP协议，为0时自动选择type默认协议 return: -1 错误； 非负值 成功 连接指定服务器 int connect(int sockfd, struct sockaddr *addr, socklen_t addrlen) sockfd：客户端的sock描述字 addr: 服务器的地址 addrlen: socket地址长度 向socket发送信息 ssize_t write(int fd, const void *buf, size_t count) fd: 发送的用户对应的套间字 buf: 缓冲区 count: 发送的信息长度 return: 如果大于零表示发送的长度，小于0表示发生错误 关闭socket int close(int fd) fd: accept返回的连接描述字，每个连接有一个，生命周期为连接周期。 实例客户端连接服务器，服务器向客户端发送当地时间，客户端接收并显示。服务器端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define DEFAULT_PORT 6666#define BUF_LEN 128struct tm *GetBeijingTime();int main()&#123; int SocketServer; struct sockaddr_in ServerAddr; char Buf[BUF_LEN]; //create socket if((SocketServer = socket(AF_INET, SOCK_STREAM, 0)) == -1)&#123; printf(&quot;create socket error!\\n&quot;); exit(0); &#125; //create addr memset((char*)&amp;ServerAddr, 0, sizeof(ServerAddr)); ServerAddr.sin_family = AF_INET; ServerAddr.sin_addr.s_addr = htonl(INADDR_ANY); ServerAddr.sin_port = htons(DEFAULT_PORT); //bind the socket with address if(bind(SocketServer, (struct sockaddr*)&amp;ServerAddr, sizeof(ServerAddr)) == -1)&#123; printf(&quot;bind socket with addr fail!\\n&quot;); exit(0); &#125; //listen if(listen(SocketServer, 20) == -1)&#123; printf(&quot;listen error!\\n&quot;); exit(0); &#125; printf(&quot;server: waitting for client connect.........\\n&quot;); //loop for accept while(1)&#123; int SocketClient; struct sockaddr_in ClientAddr; char ClientAddrString[30]; socklen_t ClientAddrLen; if((SocketClient = accept(SocketServer, (struct sockaddr*)&amp;ClientAddr, &amp;ClientAddrLen)) == -1)&#123; printf(&quot;accept socket error!\\n&quot;); exit(0); &#125; inet_ntop(AF_INET, &amp;ClientAddr.sin_addr, ClientAddrString, sizeof(ClientAddrString)); printf(&quot;server: %s connecting .....\\n&quot;, ClientAddrString); //get the time struct tm *beijingTime; beijingTime = GetBeijingTime(); sprintf(Buf, &quot;TIME: %d/%d/%d %2.2d:%2.2d:%2.2d\\n&quot;, beijingTime-&gt;tm_year, beijingTime-&gt;tm_mon, beijingTime-&gt;tm_mday, beijingTime-&gt;tm_hour, beijingTime-&gt;tm_min, beijingTime-&gt;tm_sec); //send the time if(write(SocketClient, Buf, strlen(Buf)) == 0) printf(&quot;server: send message error!\\n&quot;); //close the socket connect close(SocketClient); printf(&quot;server: close the client\\n&quot;); &#125; close(SocketServer); return 1;&#125;struct tm *GetBeijingTime()&#123; struct timeval tv; struct tm *BeijingTime; gettimeofday(&amp;tv, NULL); BeijingTime = gmtime((time_t*)&amp;(tv.tv_sec)); BeijingTime-&gt;tm_year += 1900; BeijingTime-&gt;tm_hour += 8; BeijingTime-&gt;tm_mon += 1; return BeijingTime;&#125; 客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define BUF_LEN 128int main(int argc, char** argv)&#123; int SocketClient; char Buf[BUF_LEN]; struct sockaddr_in ServerAddr; //create socket if((SocketClient = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; printf(&quot;create socket error\\n&quot;); exit(0); &#125; //set the server&apos;s addr memset((char*)&amp;ServerAddr, 0, sizeof(ServerAddr)); ServerAddr.sin_family = AF_INET; int port = atoi(argv[2]); ServerAddr.sin_port = htons(port); if(inet_pton(AF_INET, argv[1], &amp;ServerAddr.sin_addr) &lt;= 0)&#123; printf(&quot;inet_pton error!\\n&quot;); exit(0); &#125; //connect if(connect(SocketClient, (struct sockaddr*)&amp;ServerAddr, sizeof(struct sockaddr)) &lt; 0)&#123; printf(&quot;connect error!\\n&quot;); exit(0); &#125; memset(Buf, 0, BUF_LEN); //read the message from server if(recv(SocketClient, Buf, BUF_LEN, 0) &lt; 0)&#123; printf(&quot;recv error!!\\n&quot;); exit(0); &#125; printf(&quot;Client: recv from server-&gt; %s\\n&quot;, Buf); //close socket close(SocketClient); return 1;&#125;","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://victorjiangxin.github.io/tags/linux/"},{"name":"socket","slug":"socket","permalink":"http://victorjiangxin.github.io/tags/socket/"}]},{"title":"kerberos认证浅析","date":"2018-04-14T16:00:00.000Z","path":"/kerberos认证/","text":"什么是kerberosKerberos是个用于安全认证的第三方协议，它采用了传统的共享密钥的方式，实现了在网络环境不一定保证安全的环境下，Client和Server之间的通信。 kerberos协议基本原理 A与B之间有一个密钥key(A,B)，这个密钥只有它们两者拥有。当A需要向B证明它是A时，发送两条信息。一条为A的用户信息的明文，另一条为使用密钥key加密过的明文信息。B接收后，用密钥key进行解密，然后将解密后的信息与明文信息比较。如果他们是一样的，则表明对方就是A。从而，B确认A的身份。 引入KDC：key(A,B)从何而来为了保证认证的安全性，key(A,B)应该是有时效性的，不能是固定的。因此KDC在整个认证系统中起共同信任的第三方作用。 大概流程 A向KDC发出申请，申请中包含了A的身份信息 KDC查询白名单，如果A存在则向A发送两条信息 第一条为Encrypt(key(A,B), Pubkey_A)，使用A的公钥加密的key(A,B) 第二条为Encrypt(A_Info+key(A,B), Pubkey_B)，使用B的公钥加密的A_Info与key(A,B)信息 A使用私钥对Encrypt(key(A,B), Pubkey_A)信息解密，得到key(A,B) A开始向B进行认证申请，发送两条信息 第一条为Encrypt(A_Info+Timestamp, key(A,B))，使用key(A,B)加密的A_Info和时间戳信息 第二条为Encrypt(A_Info+key(A,B), Pubkey_B) B接收到A发送的信息后： 先用私钥解密Encrypt(A_Info+key(A,B), Pubkey_B)，得到key(A,B) 然后用Key(A,B)解码Encrypt(A_Info+Timestamp, key(A,B))，比较A_Info，相同则成功认证。加时间戳的目的B每次接收到A的认证信息后，如果发现时间戳与当前时间在范围外，则判定失效，保证安全Kerberos的优点 较高的性能。KDC参与次数少，相比较完全依赖可信赖的第三方方案比较，具有较大的性能提升 实现了双向验证","comments":true,"tags":[{"name":"密码学","slug":"密码学","permalink":"http://victorjiangxin.github.io/tags/密码学/"},{"name":"kerberos认证","slug":"kerberos认证","permalink":"http://victorjiangxin.github.io/tags/kerberos认证/"}]},{"title":"github使用相关","date":"2018-04-12T16:00:00.000Z","path":"/github使用相关/","text":"常用操作及代码 生成SSH key ssh -keygen -t rsa ssh -T git@github.com 克隆版本库 git clone 上传文件 git add &lt;文件名，如果是全部，可以用add .&gt; git commit -m “文件描述” git push origin master （把本地代码推送到远程master分支） git pull -u origin master (把远程代码拉下，保证代码同步) 将本地项目与Github上的一个项目进行关联。先切换到目的目录，执行下面命令,把远程仓库的名字命名为origingit remote add origin git@github.com:&lt;USERNAME&gt;/&lt;User.resource&gt;.git 提交项目前，注意！！！一定要先设置用户名与邮箱 12345678910git config —global user.name &quot;&lt;your name&gt;&quot;git config —global user.email &quot;&lt;your email&gt;&quot;``` * 创建分支 `git checkout -b &lt;branch name&gt;` # 本地已有版本库，要推送至Github首先，Github上已有一个Repository, `git@github.com:VictoryJiangXin/mShell.git`然后，进入目录，比如f:\\mShell然后命令步骤如下： git initgit remote add &lt;Repository’s name&gt; git@github.com:VictoryJiangXin/mShell.gitgit add git commit -m ““ git push -u &lt;Repository’s name&gt; master","comments":true,"tags":[{"name":"Github","slug":"Github","permalink":"http://victorjiangxin.github.io/tags/Github/"}]},{"title":"开源代码License","date":"2018-04-10T16:00:00.000Z","path":"/GithubLicense相关/","text":"概论开源代码有个很重要的文件，License这涉及到制作者的知识产权，因此特查看相关博客。下面一张图进行说明。图片来源：阮一峰 老师博客","comments":true,"tags":[{"name":"Github","slug":"Github","permalink":"http://victorjiangxin.github.io/tags/Github/"},{"name":"开源许可证","slug":"开源许可证","permalink":"http://victorjiangxin.github.io/tags/开源许可证/"}]},{"title":"SqlServer使用","date":"2018-04-10T07:01:52.000Z","path":"/SqlServer使用/","text":"Sql Server相关在使用Sql Server进行存储时，碰到两个巨大的坑！ 一个就是关于数据库版本的问题，SQL Server在WIN7系统上无法运行2017的版本，智能运行2014的版本。 一个就是SQL Server的自身版本问题，SQL Server有两种，一种是EXPRESS版，它最多只能存储10G的数据，一种是企业版，它能存储不限量的数据。 SSMS连接SQL Server数据库在使用SQL Server时，我们常常使用SSMS操作数据库，对数据库进行可视化的操作。在使用SSMS操作数据库时，首先要进行数据库连接我的数据库是默认安装的，命名为SQ2，但是，在填写数据库服务器名时，我填写SQ2，却一直无法连接到数据库，最后才发现，要使用localhost\\SQ2作为名字，才可以进行连接！","comments":true,"tags":[{"name":"数据库","slug":"数据库","permalink":"http://victorjiangxin.github.io/tags/数据库/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"http://victorjiangxin.github.io/tags/SQL-Server/"}]},{"title":"SQL数据库相关操作","date":"2018-04-03T16:00:00.000Z","path":"/数据库/","text":"数据库定义语句 CREAT语句_建表CREAT语句用于创建数据库、表、视图等操作。语句格式如下： 1234CREATE TABLE &lt;表名&gt;( &lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;], &lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;], &lt;表级完整性约束条件&gt;); &lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件常用完整性约束: 主码约束: PRIMARY KEY 参照完整性约束: 唯一性约束： UNIQUE 非空值约束： NOT NULL 取值约束： CHECK 数据类型： 在SQL Server中，有几种主要的类型——文本、数字、二进制数据和日期 文本类型 CHAR(size) 保持固定长度的字符串。n的取值：1-8000 VARCHAR(size) 保持可变长度的字符串。在括号中指定字符串的最大长度，最多为8000个字符，效率没CHAR高 TEXT 最多存放长度为 2^31-1 个字符的字符串 NCHAR(n) 固定长度，Unicode字符串数据。n的取值1-4000 NVARCHAR(n) 可变长度，Unicode字符串数据。n的取值范围1-4000 NTEXT 长度可变的Unicode数据，字符串最大长度为2^30-1 数字类型 BIT 0/1或NULL的数据类型 BIGINT 8字节存储的INT数据类型 INT 4字节存储的INT数据类型 SMALLINT 2字节存储的INT数据类型 TINYINT 1字节存储的INT数据类型 DECIMAL[(P[,S])] []表示可选择的。固定精度和小数位数，p表示精度，s表示小数位数 FLOAT[(n)] 浮点数，其中n用于存储flaot数值尾数的尾数，用于确定精度 二进制类型 BINARY(n) 固定长度，n的取值：1~8000 VARBINARY(n) 可变长度，最多为长度n，n的取值：1~8000 IMAGE 长度可变的二进制数据，从0到2^31-1个字节 时间类型 TIME 00:00:00.0000000到23:59:59:9999999 DATE 0001-01-01到9999-12-31 SMALLDATETIME 日期范围:1900-01-01到2079-06-06 时间范围:00:00:00到23:59:59 DATATIME 日期范围:1753-01-01到9999-12-31 时间范围:00:00:00到23:59:59.997 DATATIME2 日期范围:0001-01-01到9999-12-31 时间范围:00:00:00到23:59:59.9999999 举例：创建一个学生表，包括学号、姓名、性别、年龄及所在系。其中学号不能为空，且唯一，姓名取值也唯一。 1234567CREATE TABLE Student( StudentNumber CHAR(5) NOT NULL UNIQUE, StudentName CHAR(20) UNIQUE, StudentSex CHAR(1), StudentAge INT, StudentDept CHAR(15)); CREAT语句_建索引建立索引是加快查询速度的有效手段。索引建立方式： DBMS自行建立 PRIMARY KEY UNIQUE DBA或表的属主（建表的人）根据需要建立。 维护索引：DBMS自动完成语句格式:CREAT [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...); 索引可以建立在该表的一列或多列上。次序表示升序或者降序表示，升序：ASC，降序：DESC。缺省值：ASCUNIQUE表示索引的每一个索引值只对应唯一的数据记录。CLUSTER表示要建立的索引是聚簇索引。注意：如果是含重复值的属性列不能建立UNIQUE索引，聚簇索引，基表中的数据也需要按指定的聚簇属性的升序或降序存放。 ALTER语句ALTER语句用于修改各表项的内容，其语句格式如下所示： 1234ALTER TABLE &lt;表名&gt; [ADD &lt;新列名&gt; &lt;数据类型&gt; [完整性约束]] [DROP &lt;完整性约束名&gt;] [MODIFY &lt;列名&gt; &lt;数据结构&gt;]; -表名：要修改的基本表-ADD子句：增加新列和新的完整性约束条件-DROP子句：删除指定的完整性约束条件-MODIFY子句：用于修改名列名和数据类型-只能间接删除属性列 * 把表中要保留的列及其内容复制到一个新表中 * 删除原表 * 再将新表命名为原表名 -不能修改完整性约束-不能为已有列增加完整性约束举例：向Student表中增加“入学时间”列，其数据类型为日期型。 ALTER TABLE Student ADD StudentCome DATE DROP语句DROP语句用于删除表项，其语句格式如下所示： DROP TABLE &lt;表名&gt;; -系统从数据字典中删去1、该基本表的描述；2、该基本表上的所有索引的描述。-系统从文件中删去表中数据-表上的视图仍然保留，但无法引用举例：删除Student表。DROP TABLE Student 数据库操作语句查询语句查询语句表达式如下所示: 12345678SELECT [ALL|DISTICT] &lt;目标表达式&gt;[&lt;别名&gt;] [,&lt;目标表达式&gt;[&lt;别名&gt;]]FROM &lt;表名或视图名&gt;[&lt;别名&gt;] [,&lt;表名或视图名&gt;[&lt;别名&gt;]][WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名&gt;[,&lt;列名&gt;] [HAVING&lt;条件表达式&gt;]][ORDER BY &lt;列名&gt;[,&lt;列名&gt;][ASC|DESC]]; -SELECT子句：指定要显示的属性列-FROM子句：指定查询对象（基本表或视图）-WHERE字句：指定查询条件-GROUP BY字句： 对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用集函数。-HAVING短语：筛选出满足指定条件的组-ORDER BY子句：对查询结果表按指定列序的升序排序或者降序排序 WHER子句 确认范围: BETWEEN…AND… / NOT BETWEEN…AND…比如 123SELECT Sname，Sdept，SageFROM StudentWHERE Sage BETWEEN 20 AND 23； 确认集合：IN &lt;值表&gt; NOT IN &lt;值表&gt;。&lt;值表&gt;：用逗号分隔的一组取值。比如 123SELECT Sname，SsexFROM StudentWHERE Sdept IN ( &apos;IS&apos;，&apos;MA&apos;，&apos;CS&apos; ); 字符串匹配：使用谓词LIKE或NOT LIKE [NOT] LIKE ‘&lt;匹配串&gt;’[ESCAPE‘&lt;换码字符&gt;‘]比如 123456789101112SELECT * FROM Student WHERE Sno = &apos;95001&apos;；SELECT Sname，Sno，SsexFROM StudentWHERE Sname LIKE ‘刘%’；SELECT Cno，CcreditFROM CourseWHERE Cname LIKE &apos;DB\\_Design&apos; ESCAPE &apos;\\&apos;使用换码字符将通配符转义为普通字符，ESCAPE换码字符 涉及空值的查询：使用谓语 IS NULL 或 IS NOT NULL 5类主要集函数 计数 COUNT([DISTINCT|ALL]*) COUNT([DISTINCT|ALL]&lt;列名&gt;) 计算总和 SUM([DISTINCT|ALL]&lt;列名&gt;) 计算平均值 AVG([DISTINCT|ALL]&lt;列名&gt;) 求最大值 MAX([DISTINCT|ALL]&lt;列名&gt;) 求最小值 MIN([DISTINCT|ALL]&lt;列名&gt;) -DISTINCT短语：在计算中要取消指定列中的重复值-ALL短语：不取消重复值-ALL为缺省值 使用集函数12345例： 计算1号课程的学生平均成绩。 SELECT AVG(Grade) FROM SC WHERE Cno= &apos; 1 &apos;； GROUP语句与HAVING语句 使用GROUP BY进行分组 分组方法：按指定的一列或多列值分组，值相等的为一组。 使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数 GROUP BY子句的作用对象是查询的中间结果表。 使用HAVING语句筛选最终结果 只有满足HAVING短语语句指定条件的组才输出。 HAVING短语与WHERE子句的不同：作用对象不同。WHERE基于表，HAVING作用于组。 12345查询选修了3门以上课程的学生学号SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*) &gt;3； 单表查询查询只涉及一个表，是一种最简单的查询操作。如果需要显示所有的列，并且按照原表顺序，可用SELECT *子句如果要消除重复的内容，可加DISTICT语句，比如SELECT DISTICT StudentNumber 连续查询同时涉及多个表的查询称为连接查询。 123456SELECT Std.Sname, Std.Ssex, SdeptFROM Std，StdCWHERE Std.Sname = StdC.Sname /* 连接谓词 */AND Std.Ssex = StdC.Ssex /* 连接谓词 */AND StdC.Cno= &apos; 2 ‘ /* 其他限定条件 */AND StdC.Grade&gt;90； /* 其他限定条件 */ 嵌套查询概述：一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询。 123456SELECT Sname 外层查询/父查询FROM StudentWHERE Sno IN（SELECT Sno 内层查询/子查询 FROM SC WHERE Cno= &apos; 2 &apos;); 数据更新语句插入数据插入单个元组功能：将新元组插入指定表中。语句格式: 123INSERTINTO &lt;表名&gt; [(&lt;属性列1&gt;[，&lt;属性列2 &gt;…)]VALUES (&lt;常量1&gt; [，&lt;常量2&gt;]…) INTO子句 指定要插入数据的表名及属性列 属性列的顺序可与表定义中的顺序不一致 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 指定部分属性列：插入的元组在其余属性列上取空值 VALUES子句 提供的值必须与INTO子句匹配 插入子查询结果功能：将子查询结果插入指定表中。语句格式： 123INSERT INTO &lt;表名&gt; [(&lt;属性列1&gt; [，&lt;属性列2&gt;… )]子查询: INFO子句与上相同。 子查询 SELCET子句目标项必须与INFO子句匹配。 修改数据功能： 修改指定表中满足WHERE子句条件的元组。语句格式： 123UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]； SET子句 指定要修改的方式。 WHERE子句 指定要修改的元组，缺省表示要修改所有的元组。示例： 123456UPDATE SCSET Grade=0WHERE &apos;CS&apos;=(SELETE Sdept FROM Student WHERE Student.Sno = SC.Sno)； 删除数据功能： 删除指定表中满足WHERE子句条件的元组。语句格式： 123DELETEFROM &lt;表名&gt;[WHERE &lt;条件&gt;]； 视图建立视图在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。语句格式： 1234CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [，&lt;列名&gt;]…)]AS &lt;子查询&gt;[WITH CHECK OPTION]； 组成视图的属性列名或全部省略或全部指定。 省略视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成。 必须明确指定组成视图的所有列名的情形。 某个目标列不是单纯的属性名，而是集函数或列表达式 目标列为* 多表连接时选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 子查询 不含ORDER BY子句和DISTINCT短语的SELECT语句 WITH CHECK OPTION 透过视图进行增删改操作时，不得破坏视图定义中的谓词条件（即子查询中的条件表达式） JOIN语句有时为了得到完整的结果，我们需要从两个或更多的表中获取结果。我们就需要执行 join。数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。示例： 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName INNER JOIN(内连接):在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 JOIN: 如果表中有至少一个匹配，则返回行。 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行。 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行。 FULL JOIN: 只要其中一个表中存在匹配，就返回行。","comments":true,"tags":[{"name":"数据库","slug":"数据库","permalink":"http://victorjiangxin.github.io/tags/数据库/"},{"name":"SQL语句","slug":"SQL语句","permalink":"http://victorjiangxin.github.io/tags/SQL语句/"}]},{"title":"比特币：脚本与地址","date":"2018-04-01T16:00:00.000Z","path":"/bitcoininin-scriptAddr/","text":"转自: https://furrybear.github.io/%E7%AC%94%E8%AE%B0/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81%EF%BC%9A%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%9C%B0%E5%9D%80/ 一些概念 非压缩式公钥65字节（04开头） 压缩式公钥33字节（02、03开头） 公钥哈希20字节 脚本哈希20字节（或者32字节，但是没有见过实例） 地址（由公钥哈希和脚本哈希组装和编码而来） P2PKH型：1开头，例如1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2，由公钥哈希组装和编码而来 P2SH型：3开头，例如3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy，由脚本哈希组装和编码而来 bech32型：bc1来头，例如bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq，它是前两种地址的另一种表达格式，现在blockchain.info只在有“native witness program”的时候使用这种格式 签名七十几字节（由第二个字节决定 非隔离见证(无Marker和Flag的) 锁定脚本：41&lt;非压缩式公钥&gt;(65bytes)AC（1开头地址） 锁定脚本(不太确定)：（P2PK型多重签名)OP_2 &lt;公钥1&gt; &lt;公钥2&gt; &lt;公钥3&gt; OP_3 CHECKMULTISIG(0xAE)（1开头地址） 锁定脚本：76A914&lt;公钥哈希&gt;(20bytes)88AC（1开头地址） 锁定脚本：76A920&lt;公钥哈希&gt;(32bytes)87AC（1开头地址） 锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址） 锁定脚本：6A(40bytes?)（没有地址，资金锁住了）隔离见证交易（有marker和flag的） 锁定脚本：0014&lt;哈希&gt;(20bytes)（bc1开头地址） 锁定脚本：0020&lt;哈希&gt;(32bytes)（bc1开头地址） 锁定脚本：A914&lt;脚本哈希&gt;(20bytes)87（3开头地址） 锁定脚本：A920&lt;脚本哈希&gt;(32bytes)87（3开头地址）非隔离见证交易P2PKH（Pay-to-Public-Key-Hash）单签名（第一种）//解锁脚本： OP_DUP OP_HASH160锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) (20bytes) OP_EQUAL(0x87) OP_CHECKSIG(0xAC)举例：（书上说有这种交易，没有找到实例）单签名（第二种）//解锁脚本： OP_DUP OP_HASH160锁定脚本：OP_DUP(0x76) OP_HASH160(0xA9) PUSHDATA20(0x14) (20bytes) OP_EQUALVERIFY(0x88) OP_CHECKSIG(0xAC)交易举例：99c2f5d3f1a1c89a4afa522361c55664e7777c71b02fd66cdf4e2ba190551d11、5a4ebf66822b0b2d56bd9dc64ece0bc38ee7844a23ff1d7320a88c5fdb2ad3e2P2PK（Pay-to-Public-Key）单签名锁定脚本：PUSHDATA65BYTES(0x41) &lt;非压缩式公钥&gt;(65bytes) OP_CHECKSIG(0xAC)(获取公钥后需要通过HASH160获得公钥哈希)这是比特币最早的锁定脚本，coinbase一般是这种形式。交易举例：创世区块的交易多重签名锁定脚本：M PUSHDATA65(0x41) PUSHDATA65(0x41)… PUSHDATA65(0x41) N OP_CHECKMULTISIG(0xAE)（因为实例没有找到，这个锁定脚本形式有待验证，因为M是个操作数，但是之前没有操作码）交易举例：（没找到）P2SH赎回脚本（2-3）：OP_2(0x52)OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥1&gt;OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥2&gt;OP_PUSHDATA33BYTES(0x21)&lt;压缩式公钥3&gt;OP_3(0x53)OP_CHECKMULTISIG(0xAE)解锁脚本：OP_PUSHDATA?BYTESOP_PUSHDATA?BYTESOP_PUSHDATA?BYTES &lt;赎回脚本&gt;锁定脚本：HASH160(0xA9)PUSHDATA20(0x14) &lt;脚本哈希（赎回脚本的HASH160）&gt;(20bytes) OP_EQUAL(0x87)举例：txid为521f7c6781ced91da6cc8eb4c64b283d2e99f98627daf8a3a0c60432d8e8f601的输入解锁脚本：12345678910111213141500//这是要注意！这是什么？？？版本号？OP_PUSHDATA71BYTES(0x47)3044022027eec2f3081b87d271e32e126c9ccb4d2c4afa7ef14f7cff644723784b720ede02203e278a13e3544bd32abe6592e4e17a7331272db4a2b780113ed24e3ca3c37f3201//签名1OP_PUSHDATA72BYTES(0x48)30450221009e450de0b27f95db02d7ab8b5943c62b8e2f50eabfb017f509684c4f58892d7802203b8640c5f17b8e6239a65f66bbb26ea952dac9d0eefffd114d97878b2ac1da4f01//签名1OP_PUSHDATA1(0x4c)69OP_2(0x52)OP_PUSHDATA33BYTES(0x21)02ca355b567bff51c9b4a1c1590e25f685f8d12273efb7f7685a50e546786d0de7//公钥1OP_PUSHDATA33BYTES(0x21)03e5fa93cffa7533c6b68906c4a9b8665f5167f3ed95b830328835ca4d39b6495f//公钥2OP_PUSHDATA33BYTES(0x21)03ee6664f625e0a44fad0ad53ae1ecdc7c7239346b81514e8f87cfd2be4f8fec21//公钥3OP_3(0x53) OP_CHECKMULTISIG(0xae) 锁定脚本：a914d0982dd391d674f101898e8500586019e01d9aa787 OPRETURN锁定脚本：OP_RETURN(0x6A) (40bytes?)输出不能被花费。 纯隔离见证交易witness_version在witness字段内，锁定脚本必然以一个版本号开头 P2WPKH（pay-to-witness-public-key-hash）witness:解锁脚本: 空锁定脚本: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;公钥哈希&gt;(20bytes) 交易举例：没有找到实例…… P2WSH（pay-to-witness-script-hash）witness: witness_version(0x00) OP_PUSHDATA?BYTES &lt;签名1&gt; OP_1 OP_PUSHDATA33BYTES &lt;压缩式公钥1&gt; OP_PUSHDATA33BYTES &lt;压缩式公钥2&gt; OP_2 OP_CHECKMULTISIG(0xAE)解锁脚本: 空锁定脚本1: witness_version(0x00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt;(32bytes)锁定脚本2: witness_version(0x00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes)锁定脚本3: witness_version(非0x00) PUSHDATA任意BYTES &lt;脚本哈希&gt;(任意bytes)(注意：P2SH的脚本哈希只有20字节，这里可以20字节或者32字节，32字节是为了防碰撞)交易举例：txid为d38f496e1004895c52d35bfe392800024b78b40e30dd063c4728058088ea0620交易的输入witness： 1234567891011121314151604//？？witness_version(0x00)47304402203f87ea2cb39bf7b57f0ada40cfa7178a7b11548767d17be57e0e3a9ed818e53902202323afa3875a9917bf8227051ea5805ea5bc7a71f1ef8176884964a278aa2c2b01//签名47304402201055076d4a5284509a8c3e01abbe5e34e4fd79fe823914821bcaa7924333e0e40220495237c0d9acd7f16357de8c89e4eaab620ce5d26b810214e96272f4cf27b54e01//签名OP_VERIFY(0x69)OP_2(0x52)210375e00eb72e29da82b89367947f29ef34afb75e8654f6ea368e0acdfd92976b7c//公钥2103a1b26313f430c4b15bb1fdce663207659d8cac749a0e53d70eff01874496feff//公钥2103c96d495bfdd5ba4145e3e046fee45e84a8a48ad05bd8dbb395c011a32cf9f880//公钥OP_3(0x53)ae 将P2WPKH和P2WSH的witness program嵌入P2SH赎回脚本的部分witness_version在解锁脚本内。 P2WPKH nested in BIP16 P2SHwitness:解锁脚本: PUSHDATA22BYTES(0x16) witness_version(00)PUSHDATA22BYTES(0x14) &lt;公钥哈希&gt;(20bytes)锁定脚本: OP_HASH160(0xA9) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt;(20bytes) OP_EQUAL(0x87) 举例：交易c420d6cf09973d4a539cb17acdc42a3a89a89e0d6e28938a37951085d8433125的输出 P2WSH nested in BIP16 P2SHwitness:0 &lt;1 2 CHECKMULTISIG&gt;解锁脚本1: PUSHDATA34BYTES(0x22) witness_version(00) PUSHDATA32BYTES(0x20) &lt;脚本哈希&gt; (32bytes)解锁脚本2: PUSHDATA22BYTES(0x16) witness_version(00) PUSHDATA20BYTES(0x14) &lt;脚本哈希&gt; (20bytes)锁定脚本: OP_HASH160(0xa9) OP_PUSHDATA20(0x14) &lt;20-byte-hash&gt; OP_EQUAL(0x87) 交易举例：4967d6427b17a17e91b524e9a4f8a810182c5f9995fd07fe2eab71d9cc96ecc0","comments":true,"tags":[{"name":"比特币脚本","slug":"比特币脚本","permalink":"http://victorjiangxin.github.io/tags/比特币脚本/"},{"name":"隔离见证","slug":"隔离见证","permalink":"http://victorjiangxin.github.io/tags/隔离见证/"}]},{"title":"异步编程C#","date":"2018-03-21T16:00:00.000Z","path":"/异步编程/","text":"Task与Thread的区别 Thread每次运行会创建一个新的线程，线程的创建、结束带来大量的开销。 Task每次运行时，会去线程池中寻找空闲的线程，将其分配使用。 Task及awit/asyncasync/await 结构可分成三部分： （1）调用方法：该方法调用异步方法，然后在异步方法执行其任务的时候继续执行； （2）异步方法：该方法异步执行工作，然后立刻返回到调用方法； （3）await 表达式：用于异步方法内部，指出需要异步执行的任务。一个异步方法可以包含多个 await 表达式（不存在 await 表达式的话 IDE 会发出警告）。 如何看异步代码？async定义的函数可分为以下几部分： await之前的部分；await部分；await之后的部分。当主函数运行到async函数时，先运行await之前的部分，遇到await后，线程分为两部分，（此时主线程从async函数中已经返回了）一个线程在主函数中继续运行，另一线程在继续运行await函数。PS:async函数内部的执行顺序，还是不变的，严格从上往下执行，即使有多个awit关键词，仍旧执行完前一个await语句后，再执行后一个await语句。 示例代码与输出12345678910111213141516171819202122232425262728293031class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(&quot;main thread start!&quot;); Task t = TestAsync(); Console.WriteLine(&quot;main thread end!&quot;); Console.Read(); &#125; private static async Task TestAsync() &#123; Console.WriteLine(&quot;Task start!&quot;); await Task.Run(() =&gt; &#123; Console.WriteLine(&quot;await0 start!&quot;); for (int i = 0; i &lt; 500000; i++) ; Console.WriteLine(&quot;await0 end!&quot;); &#125;); await Task.Run(()=&gt; &#123; Console.WriteLine(&quot;awit1 start!&quot;); for (int i = 0; i &lt; 5; i++) ; Console.WriteLine(&quot;awit1 end!&quot;); &#125; ); &#125; &#125; 运行结果如下所示： 1234567main thread start!Task start!await0 start!main thread end!await0 end!awit1 start!awit1 end!","comments":true,"tags":[{"name":"C#","slug":"C","permalink":"http://victorjiangxin.github.io/tags/C/"},{"name":"异步编程","slug":"异步编程","permalink":"http://victorjiangxin.github.io/tags/异步编程/"}]}]